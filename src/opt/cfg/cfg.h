#pragma once

#include "optnode.h"
#include <queue>
#include <unordered_set>
#include <unordered_map>

namespace dark::OPT {


/**
 * @brief This is helper class that removes all useless nodes.
 * Note that after this function, the CFG graph is still valid.
 * But the function might become unreachable.
 * Consequently, we need to use test whether the function is reachable
 * before going on using the pass.
 * 
*/
struct unreachable_remover {
    std::unordered_set <IR::block_stmt *> block_set;
    std::vector <node *> work_list;
    unreachable_remover(IR::function *,node *);

    /* Insert those reachable blocks. */
    void update_dfs_front(node *);
    /* Insert those blocks that can be reached from entry and exit.  */
    void update_dfs_reverse();

    /**
     * @brief Update branch jump from unreachable branches.
     * Note that this may result in single phi! (e.g: %1 = phi[1,%entry])
     * In addition, any branch to unreachable block will be replaced with jump.
    */
    void update_phi_branch_source();
    /* Remove all unreachable blocks in function.(CFG irrelated.) */
    void remove_unreachable(IR::function *);

};

/**
 * @brief This is helper class that will cut all constant branches.
 * Constant branches are commonly generated by constant propagation,
 * so use it after constant propagation is a good idea.
 * In addition, after branch cut, more jumps are generated, so it 
 * can be used to compress single phi and remove useless jumps.
 * 
*/
struct branch_cutter {
    branch_cutter(IR::function *,node *);
};

/**
 * @brief This is helper class that will compress useless branch.
 * e.g. BB1 -> BB2 -> BB3 will be compressed to BB1 -> BB3.
 * In addition, it can remove some conditional branches, which
 * may lead to potential dead code elimination.
 * 
 */
struct branch_compressor {
    /* Add to the work list !!! */
    std::vector <node *> work_list;
    std::vector <IR::node *> remove_list;

    std::unordered_set <node *> visit;

    struct block_info {
        IR::block_stmt  *block = nullptr;
        size_t           count = 0;
    };

    /* Sometimes, simpler is better~ */
    struct usage_info {
        IR::node *def_node  = nullptr;
        size_t    ref_count = 0;
        block_info * block  = 0;
    };

    std::unordered_map <IR::temporary *,usage_info> use_map;

    branch_compressor(IR::function *,node *);

    bool compress_line(node *,node *);
    void compress_branch(node *,node *);
    void remove_block(IR::function *,node *);
    void try_remove_useless(IR::definition *);
    static void update_branch(IR::branch_stmt *,node *,node *,node *);
};


}